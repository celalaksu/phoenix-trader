/* eslint-disable @typescript-eslint/no-explicit-any */
import { Connection, PublicKey, TransactionSignature } from "@solana/web3.js";
import base58 from "bs58";
import { Client as RpcWsClient } from "rpc-websockets";
import {
  FillEvent,
  getPhoenixEventsFromLogData,
  PhoenixEventsFromInstruction,
  isPhoenixMarketEventFill,
  sign,
  toBN,
  toNum,
  PhoenixMarketEvent,
  PROGRAM_ID,
  logInstructionDiscriminator,
  MarketState,
} from "@ellipsis-labs/phoenix-sdk";
import BN from "bn.js";

type SubscriptionMetadata = {
  accountFilter: PublicKey[];
  initial: boolean;
  callback: (data: any) => void;
};

export class Whirligig {
  connected = false;
  private ws: RpcWsClient;

  // An atomically incrementing counter that we use to generate proxy subscription IDs.
  // A proxy subscription ID is a unique internal counter that is used to map to the
  // server subscription ID.
  private nextProxySubscriptionId = 0;

  // This is a map of proxy subscription IDs to callbacks. It will be populated only
  // when the client is not connected but still receives a subscription request.
  // On reconnect, it will be deleted.
  private pendingSubscriptionMap: Map<number, SubscriptionMetadata> = new Map();

  // This is a map of server subscription IDs to callbacks and subscription request params.
  private subscriptionMap: Map<number, SubscriptionMetadata> = new Map();

  // This is a map that allows us to convert from an internal subscription ID to the
  // ID that the server is using.
  private proxyMap: Map<number, number> = new Map();

  // Keeps track of the number of times that the websocket has reconnected
  private reconnectCounter = 0;

  constructor(url: string) {
    // `autoconnect` is set to true so the websocket will automatically connect upon instantiation.
    // `reconnect` is set to true so the websocket will automatically reconnect if the connection closes.
    // `max_reconnects` is the number of times that the websocket will attempt to reconnect before giving up.
    this.ws = new RpcWsClient(url, {
      autoconnect: true,
      reconnect: true,
      max_reconnects: 1 << 32,
    });
    console.log(new Date(), "[Whirligig] Initialized Whirligig");

    this.ws.on("transactionNotification", (data: any) => {
      const subscriptionId = data.subscription;
      const payload = data.result.value;
      const tx = payload.transaction;
      const txMeta = payload.meta;
      const signature = base58.encode(payload.signature);
      const message =
        Array.isArray(tx.message) && tx.message.length > 0
          ? tx.message[tx.message.length - 1]
          : tx.message;
      const accountKeys = [
        message.accountKeys.slice(1).map((k: number[]) => base58.encode(k)),
        txMeta.loadedAddresses.writable,
        txMeta.loadedAddresses.readonly,
      ].flat();
      const subscriptionMetadata = this.subscriptionMap.get(subscriptionId);
      if (subscriptionMetadata) {
        subscriptionMetadata.callback({
          transaction: tx,
          meta: txMeta,
          signature,
          accountKeys,
          initial: subscriptionMetadata.initial,
        });
        // Unset the subscription after the first notification
        subscriptionMetadata.initial = false;
      } else {
        console.log(
          "Received transaction notification for unknown ID: ",
          subscriptionId
        );
      }
    });

    this.ws.on("open", async () => {
      console.log(
        new Date(),
        `[Whirligig] Websocket connected (attempt ${this.reconnectCounter})`
      );
      this.connected = true;
      const subscribePromises = [];
      const unsubscribePromises: number[] = [];
      for (const [
        proxySubscriptionId,
        subscriptionMetadata,
      ] of this.pendingSubscriptionMap.entries()) {
        const accountFilter = subscriptionMetadata.accountFilter;
        subscribePromises.push(
          // Trigger the subscription for all pending requests
          this._transactionSubscribe(accountFilter).then(
            (newSubscriptionId) => {
              if (this.pendingSubscriptionMap.has(proxySubscriptionId)) {
                // Update the proxy destination
                this.proxyMap.set(proxySubscriptionId, newSubscriptionId);
                // Remove the pending subscription
                this.pendingSubscriptionMap.delete(proxySubscriptionId);
                // Replace it with the new subscription
                this.subscriptionMap.set(
                  newSubscriptionId,
                  // initial will be set to true so that the callback will know to resynchronize the state
                  subscriptionMetadata
                );
              } else {
                // If the subscription was cancelled while we were waiting for the Promise to resolve,
                // unsubscribe from the server
                console.error(
                  "[Whirligig] Pending subscription was cancelled while waiting for Promise to resolve:",
                  proxySubscriptionId
                );
                unsubscribePromises.push(proxySubscriptionId);
              }
            }
          )
        );
      }
      for (const [
        proxySubscriptionId,
        subscriptionId,
      ] of this.proxyMap.entries()) {
        const subscriptionMetadata = this.subscriptionMap.get(subscriptionId);
        if (subscriptionMetadata) {
          const accountFilter = subscriptionMetadata.accountFilter;
          // Reset the initial flag so that the callback will know to resynchronize the state
          subscriptionMetadata.initial = true;
          subscribePromises.push(
            // Resubscribe to all outstanding subscriptions
            this._transactionSubscribe(accountFilter).then(
              (newSubscriptionId) => {
                if (this.proxyMap.has(proxySubscriptionId)) {
                  // Update the proxy destination
                  this.proxyMap.set(proxySubscriptionId, newSubscriptionId);
                  // Remove the stale subscription
                  this.subscriptionMap.delete(subscriptionId);
                  // Replace it with the new subscription
                  this.subscriptionMap.set(
                    newSubscriptionId,
                    subscriptionMetadata
                  );
                } else {
                  // If the subscription was cancelled while we were waiting for the Promise to resolve,
                  // unsubscribe from the server
                  console.error(
                    "[Whirligig] Existing subscription was cancelled while waiting for Promise to resolve:",
                    proxySubscriptionId
                  );
                  unsubscribePromises.push(proxySubscriptionId);
                }
              }
            )
          );
        }
      }
      await Promise.all(subscribePromises);
      // Unsubscribe from all stale subscriptions
      await Promise.all(
        unsubscribePromises.map((proxySubscriptionId) =>
          this.transactionUnsubscribe(proxySubscriptionId)
        )
      );
      console.log(
        new Date(),
        "[Whirligig] Re-subscribed to all pending and outstanding subscriptions"
      );
      this.reconnectCounter += 1;
    });

    this.ws.on("error", (e) => {
      console.error(new Date(), "[Whirligig] Websocket error", e);
    });

    this.ws.on("close", () => {
      console.log(
        new Date(),
        `[Whirligig] Websocket closed (attempt ${this.reconnectCounter})`
      );
      this.connected = false;
    });
  }

  private async _transactionSubscribe(accounts: PublicKey[]): Promise<number> {
    const subscriptionId = (await this.ws.call("transactionSubscribe", [
      {
        mentions: accounts.map((a) => a.toBase58()),
        failed: false,
        vote: false,
      },
      { commitment: "confirmed" },
    ])) as number;
    console.log("[Whirligig] Subscribed: ", subscriptionId);
    return subscriptionId;
  }

  async transactionSubscribe(
    accountFilter: PublicKey[],
    callback: (data: any) => void
  ): Promise<number> {
    const proxySubscriptionId = this.nextProxySubscriptionId;
    this.nextProxySubscriptionId += 1;
    if (this.connected) {
      // In the case that we are already connected, we can just subscribe directly
      const subId = await this._transactionSubscribe(accountFilter);
      this.subscriptionMap.set(subId, {
        accountFilter,
        callback,
        initial: true,
      });
      this.proxyMap.set(proxySubscriptionId, subId);
    } else {
      // In the case that we are not connected, we need to store the subscription parameters
      // to be used when we reconnect.
      this.pendingSubscriptionMap.set(proxySubscriptionId, {
        accountFilter,
        callback,
        initial: true,
      });
    }
    return proxySubscriptionId;
  }

  async transactionUnsubscribe(proxySubscriptionId: number): Promise<void> {
    const subscriptionId = this.proxyMap.get(proxySubscriptionId);
    if (subscriptionId === undefined) {
      console.log(
        "[Whirligig] Unknown proxy subscription ID: ",
        proxySubscriptionId
      );
      // This will most likely be a no-op, but we remove the proxySubscription from
      // the pending map if it exists.
      this.pendingSubscriptionMap.delete(proxySubscriptionId);
      return;
    }
    // Remove proxySubscriptionId from proxy map
    this.proxyMap.delete(proxySubscriptionId);
    // Remove subscriptionId from subscription map
    this.subscriptionMap.delete(subscriptionId);
    if (this.connected) {
      await this.ws
        .call("transactionUnsubscribe", [subscriptionId])
        .then(() => {
          console.log("[Whirligig] Unsubscribed: ", subscriptionId);
        });
    } else {
      console.log(
        "[Whirligig] Attempted to unsubscribe but websocket is not connected:",
        subscriptionId
      );
    }
  }
}

export interface Trade {
  unixTimestampInSeconds: number;
  direction: number;
  signature: TransactionSignature;
  maker: string;
  taker: string;
  sequenceNumber: number;
  orderSequenceNumber?: BN;
  index: number;
  priceInTicks: number;
  quantityInBaseLots: number;
}

export const getFillEventFromMarketEvent = (
  marketEvent: PhoenixMarketEvent,
  timestamp: number,
  sequenceNumber: number,
  transactionSignature: TransactionSignature,
  signer: PublicKey
): Trade => {
  if (!isPhoenixMarketEventFill(marketEvent)) {
    throw new Error("Expected fill event");
  }

  const fillEvent = marketEvent.fields[0] as FillEvent;
  const priceInTicks = toNum(fillEvent.priceInTicks);
  const quantityInBaseLots = toNum(fillEvent.baseLotsFilled);
  return {
    unixTimestampInSeconds: timestamp,
    signature: transactionSignature,
    direction: sign(toBN(fillEvent.orderSequenceNumber).fromTwos(64)),
    maker: fillEvent.makerId.toBase58(),
    taker: signer.toBase58(),
    sequenceNumber,
    orderSequenceNumber: toBN(fillEvent.orderSequenceNumber),
    index: fillEvent.index,
    priceInTicks,
    quantityInBaseLots,
  };
};

export const parseFills = (
  signature: TransactionSignature,
  ixEvents: PhoenixEventsFromInstruction
): Trade[] => {
  const timestamp: number = toNum(ixEvents.header.timestamp);
  const sequenceNumber: number = toNum(ixEvents.header.sequenceNumber);
  const events: Trade[] = [];
  for (const e of ixEvents.events) {
    switch (e.__kind) {
      case "Fill":
        events.push(
          getFillEventFromMarketEvent(
            e,
            timestamp,
            sequenceNumber,
            signature,
            ixEvents.header.signer
          )
        );
        break;
      default:
        break;
    }
  }
  return events;
};

const parseTxData = (txData: WhirligigTxData, market: MarketState) => {
  const transactionEvents = [];
  for (const ix of txData.meta.innerInstructions) {
    for (const innerIx of ix.instructions) {
      const program = txData.accountKeys[innerIx.programIdIndex];
      if (program !== PROGRAM_ID.toBase58()) {
        continue;
      }
      const data = base58.decode(innerIx.data);
      if (data[0] === logInstructionDiscriminator) {
        const events = getPhoenixEventsFromLogData(data.slice(1));
        if (events.header.market.toBase58() !== market.address.toBase58()) {
          continue;
        }
        // Parse events into events relevant for building the state of the book - places, reduces, and trades
        const trades = parseFills(txData.signature, events);
        transactionEvents.push(trades);
      }
    }
  }
  for (const trade of transactionEvents.flat()) {
    console.log(
      new Date(trade.unixTimestampInSeconds * 1000),
      trade.direction === 1 ? "BUY" : "SELL",
      market.baseLotsToRawBaseUnits(trade.quantityInBaseLots),
      "@",
      market.ticksToFloatPrice(trade.priceInTicks),
      `taker:${trade.taker}`,
      `maker:${trade.maker}`
    );
  }
};

export interface WhirligigTxData {
  transaction: any;
  meta: any;
  signature: string;
  accountKeys: string[];
  initial: boolean;
}

const main = async () => {
  const url = process.argv[2];
  const connection = new Connection(url, "confirmed");
  console.log(url);
  const marketKey = "4DoNfFBfF7UokCC2FQzriy7yHK6DY6NVdYpuekQ5pRgg";

  const market = await MarketState.loadFromAddress({
    connection,
    address: new PublicKey(marketKey),
  });

  const wsUrl = "wss://" + url.split("://")[1] + "/whirligig";
  const accountFilter = [new PublicKey(marketKey)];
  const whirligig = new Whirligig(wsUrl);
  const proxySubscriptionId = await whirligig.transactionSubscribe(
    accountFilter,
    (data: WhirligigTxData) => {
      parseTxData(data, market);
    }
  );
  console.log("Subscribed with proxy ID: ", proxySubscriptionId);
  let i = 0;
  while (++i) {
    await new Promise((r) => setTimeout(r, 1000));
  }
};

(async function () {
  try {
    await main();
  } catch (err) {
    console.log("Error: ", err);
    process.exit(1);
  }

  process.exit(0);
})();
