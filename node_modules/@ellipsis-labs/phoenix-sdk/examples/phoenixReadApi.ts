import {
  ComputeBudgetInstruction,
  ComputeBudgetProgram,
  Connection,
  Keypair,
  PublicKey,
  SystemProgram,
  Transaction,
  TransactionInstruction,
  VersionedTransaction,
} from "@solana/web3.js";

import { deserialize } from "borsh";
import {
  L2Book,
  L2BookWithOpenOrders,
  PhoenixReadApiSchema,
  RawL3BookWithoutTraders,
} from "./phoenixReadApiTypes";

export const PHOENIX_READ_API_PROGRAM_ID =
  "ApiQkrjpq69yvKwGbqHCUbWjjrtjpgr7QAN8X4kdTq8r";
export const READ_API_BENEFACTOR =
  "GJRs4FwHtemZ5ZE9x3FNvJ8TMwitKTh21yxdRPqn7npE";

enum ReadApiInstruction {
  L2Book = 0,
  L3Book = 1,
  OpenOrders = 2,
  L2BookAndOpenOrders = 3,
  GetTraderBalances = 4,
  L3WithNoTraders = 5,
  L3BookAndOpenOrders = 6,
}

const getSetupInststructionsAndBufferKeypair = (): [
  TransactionInstruction[],
  Keypair
] => {
  // Request the max compute units in for the simulation
  const computeBudgetInstruction = ComputeBudgetProgram.setComputeUnitLimit({
    units: 1_400_000,
  });

  const bufferKeypair = Keypair.generate();
  const bufferKey = bufferKeypair.publicKey;

  const createAccountInstruction = SystemProgram.createAccount({
    fromPubkey: new PublicKey(READ_API_BENEFACTOR),
    newAccountPubkey: bufferKey,
    lamports: 69_600_890_880, // Rent exemption balance for 10_000_000 bytes
    space: 10_000_000,
    programId: new PublicKey(PHOENIX_READ_API_PROGRAM_ID),
  });

  return [[computeBudgetInstruction, createAccountInstruction], bufferKeypair];
};

export const getMarketL2Book = async (
  connection: Connection,
  marketKey: PublicKey,
  traderKey?: PublicKey
): Promise<null | undefined> => {
  // Request the max compute units in for the simulation

  const [instructions, bufferKeypair] =
    getSetupInststructionsAndBufferKeypair();

  const bufferKey = bufferKeypair.publicKey;

  // Returns a different list of keys based on whether the trader key is provided
  const keys = traderKey
    ? [
        {
          pubkey: new PublicKey(READ_API_BENEFACTOR),
          isSigner: true,
          isWritable: false,
        },
        {
          pubkey: marketKey,
          isSigner: false,
          isWritable: false,
        },
        {
          pubkey: traderKey,
          isSigner: false,
          isWritable: false,
        },
        {
          pubkey: bufferKey,
          isSigner: false,
          isWritable: true,
        },
      ]
    : [
        {
          pubkey: new PublicKey(READ_API_BENEFACTOR),
          isSigner: true,
          isWritable: false,
        },
        {
          pubkey: marketKey,
          isSigner: false,
          isWritable: false,
        },
        {
          pubkey: bufferKey,
          isSigner: false,
          isWritable: true,
        },
      ];

  const getMarketL2BookInstruction = new TransactionInstruction({
    programId: new PublicKey(PHOENIX_READ_API_PROGRAM_ID),
    keys,
    data: Buffer.from([
      traderKey
        ? ReadApiInstruction.L2BookAndOpenOrders
        : ReadApiInstruction.L2Book,
    ]),
  });

  let transaction = new Transaction().add(
    ...instructions,
    getMarketL2BookInstruction
  );

  transaction.recentBlockhash = (
    await connection.getLatestBlockhash()
  ).blockhash;

  transaction.feePayer = new PublicKey(READ_API_BENEFACTOR);

  transaction.addSignature(
    new PublicKey(READ_API_BENEFACTOR),
    Buffer.alloc(64)
  );
  transaction.addSignature(bufferKey, Buffer.alloc(64));

  const result = await connection.simulateTransaction(
    new VersionedTransaction(transaction.compileMessage(), [
      Buffer.alloc(64),
      Buffer.alloc(64),
    ]),
    {
      sigVerify: false,
      accounts: {
        encoding: "base64", // TODO: web3.js doesn't support zstd encoding
        addresses: [bufferKey.toBase58()],
      },
      replaceRecentBlockhash: true,
    }
  );

  if (result.value.accounts === undefined || result.value.accounts === null) {
    return;
  }

  const bufferAccount = result.value.accounts[0];

  if (bufferAccount === undefined || bufferAccount === null) {
    return;
  }

  const bufferData = Buffer.from(bufferAccount.data[0], "base64");

  const book = deserialize(PhoenixReadApiSchema, L2Book, bufferData);

  console.log(book);
  return null;
};

export const getMarketL3Book = async (
  connection: Connection,
  marketKey: PublicKey,
  traderKey?: PublicKey
): Promise<null | undefined> => {
  // Request the max compute units in for the simulation

  const [instructions, bufferKeypair] =
    getSetupInststructionsAndBufferKeypair();

  const bufferKey = bufferKeypair.publicKey;

  // Returns a different list of keys based on whether the trader key is provided
  const keys = traderKey
    ? [
        {
          pubkey: new PublicKey(READ_API_BENEFACTOR),
          isSigner: true,
          isWritable: false,
        },
        {
          pubkey: marketKey,
          isSigner: false,
          isWritable: false,
        },
        {
          pubkey: traderKey,
          isSigner: false,
          isWritable: false,
        },
        {
          pubkey: bufferKey,
          isSigner: false,
          isWritable: true,
        },
      ]
    : [
        {
          pubkey: new PublicKey(READ_API_BENEFACTOR),
          isSigner: true,
          isWritable: false,
        },
        {
          pubkey: marketKey,
          isSigner: false,
          isWritable: false,
        },
        {
          pubkey: bufferKey,
          isSigner: false,
          isWritable: true,
        },
      ];

  const getMarketL2BookInstruction = new TransactionInstruction({
    programId: new PublicKey(PHOENIX_READ_API_PROGRAM_ID),
    keys,
    data: Buffer.from([ReadApiInstruction.L3WithNoTraders]),
  });

  let transaction = new Transaction().add(
    ...instructions,
    getMarketL2BookInstruction
  );

  transaction.recentBlockhash = (
    await connection.getLatestBlockhash()
  ).blockhash;

  transaction.feePayer = new PublicKey(READ_API_BENEFACTOR);

  transaction.addSignature(
    new PublicKey(READ_API_BENEFACTOR),
    Buffer.alloc(64)
  );
  transaction.addSignature(bufferKey, Buffer.alloc(64));

  const result = await connection.simulateTransaction(
    new VersionedTransaction(transaction.compileMessage(), [
      Buffer.alloc(64),
      Buffer.alloc(64),
    ]),
    {
      sigVerify: false,
      accounts: {
        encoding: "base64", // TODO: web3.js doesn't support zstd encoding
        addresses: [bufferKey.toBase58()],
      },
      replaceRecentBlockhash: true,
    }
  );

  if (result.value.accounts === undefined || result.value.accounts === null) {
    return;
  }

  const bufferAccount = result.value.accounts[0];

  if (bufferAccount === undefined || bufferAccount === null) {
    return;
  }

  const bufferData = Buffer.from(bufferAccount.data[0], "base64");

  // console.log(bufferData);

  const book = deserialize(
    PhoenixReadApiSchema,
    RawL3BookWithoutTraders,
    bufferData
  );

  // console.log(book);
  return null;
};

(async function () {
  try {
    await getMarketL3Book(
      new Connection("https://api.mainnet-beta.solana.com"),
      new PublicKey("4DoNfFBfF7UokCC2FQzriy7yHK6DY6NVdYpuekQ5pRgg")
    );
  } catch (err) {
    console.log("Error: ", err);
    process.exit(1);
  }

  process.exit(0);
})();
